<% if @grammar.modulename %>
module <%= @grammar.modulename %>;

<% end %>
class <%= classname %>
{
    enum
    {
<% @grammar.tokens.each_with_index do |token, index| %>
<%   if token.name %>
        TOKEN_<%= token.c_name %> = <%= index %>,
<%   end %>
<% end %>
    }

    static immutable string TokenNames[] = [
<% @grammar.tokens.each_with_index do |token, index| %>
<%   if token.name %>
        "<%= token.name %>",
<%   else %>
        null,
<%   end %>
<% end %>
    ];

    private struct Transition
    {
        uint first;
        uint last;
        uint destination;
    }

    private struct LexerState
    {
        uint transition_table_index;
        uint n_transitions;
        uint accepts;
    }

<% transition_table, state_table = lexer_dfa.build_tables %>
    private static const Transition transitions[] = [
<% transition_table.each do |transition_table_entry| %>
        Transition(<%= transition_table_entry[:first] %>u, <%= transition_table_entry[:last] %>u, <%= transition_table_entry[:destination] %>u),
<% end %>
    ];

    private static const LexerState lexer_states[] = [
<% state_table.each do |state_table_entry| %>
        LexerState(<%= state_table_entry[:transition_table_index] %>u, <%= state_table_entry[:n_transitions] %>u, <%= state_table_entry[:accepts] %>u),
<% end %>
    ];

    static string[] lex(const(ubyte)[] input)
    {
        string[] tokens;
        string token = lex_token(&input);
        if (token !is null)
        {
            tokens ~= token;
        }
        return tokens;
    }

    private static string lex_token(const(ubyte)[] * input)
    {
        return null;
    }
}
